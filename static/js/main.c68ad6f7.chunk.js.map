{"version":3,"sources":["components/Button/Button.module.css","logo.svg","components/App/App.module.css","utils/storage.ts","reducers/generator/actions.ts","reducers/generator/types.ts","utils/commonFunctions.ts","utils/MarkovChainGenerator.ts","components/Button/Button.tsx","components/App/App.tsx","serviceWorker.js","reducers/generator/index.ts","reducers/index.ts","index.tsx"],"names":["module","exports","button","disabled","__webpack_require__","p","App","App-logo","App-logo-spin","App-header","App-link","joke","loader","spin","storage","set","get","key","value","item","JSON","stringify","localStorage","setItem","concat","toUpperCase","getItem","parse","e","STORED_JOKES","fetchAllJokes","_ref","Object","asyncToGenerator","regenerator_default","a","mark","_callee","dispatch","response","fetchedJokes","totalPages","i","_fetchedJokes","wrap","_context","prev","next","type","axios","sent","data","results","total_pages","push","apply","toConsumableArray","payload","t0","error","stop","this","_x","arguments","isQuestion","sentence","match","notEndingWords","shouldEndSentence","word","upperLimit","len","undefined","length","possibleEnding","find","w","generateHash","Math","random","toString","substring","MarkovChainGenerator","jokes","_this","classCallCheck","updateStartWords","startWords","addNewWordPairToChain","firstWord","secondWord","hashMap","count","words","defineProperty","increaseCountForAdjacentWord","getRandomWordFromBeginning","numWords","keys","reduce","b","randomWord","floor","some","getRandomWordFromAnotherWord","foundWord","handleSentenceEnd","indexOf","slice","generateSentence","prevWord","minimumWords","replace","trim","wordCount","updateStorage","id","calculateState","generateJoke","firstSentence","secondSentence","tokenizeWords","_this2","forEach","jokeObj","jokeString","_this3","jokeWords","split","index","toLowerCase","initialIsCapital","Button","onClick","title","react","className","styles","state","fetchJokes","setState","props","generator","isFetching","src","logo","alt","components_Button_Button","React","connect","_ref2","isLoading","bindActionCreators","Boolean","window","location","hostname","initialState","fetched","reducers","combineReducers","action","objectSpread","defaults","headers","common","rootEl","document","getElementById","store","createStore","applyMiddleware","thunk","render","es","components_App_App","navigator","serviceWorker","ready","then","registration","unregister"],"mappings":"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","file":"static/js/main.c68ad6f7.chunk.js","sourcesContent":["// extracted by mini-css-extract-plugin\nmodule.exports = {\"button\":\"Button_button__357J1\",\"disabled\":\"Button_disabled__1GHip\"};","module.exports = __webpack_public_path__ + \"static/media/logo.5d5d9eef.svg\";","// extracted by mini-css-extract-plugin\nmodule.exports = {\"App\":\"App_App__28qQu\",\"App-logo\":\"App_App-logo__44UpN\",\"App-logo-spin\":\"App_App-logo-spin__2F5pN\",\"App-header\":\"App_App-header__1UAaz\",\"App-link\":\"App_App-link__xg_rF\",\"joke\":\"App_joke__27b-Q\",\"loader\":\"App_loader__1kFsM\",\"spin\":\"App_spin__1VJov\"};","interface Storage {\n    set: any;\n    get: any;\n}\n\nconst storage: Storage = {\n  set: () => {},\n  get: null,\n};\n\nconst prefix: string = \"MARKOV_CHAIN\";\n\nstorage.set = (key: string, value: any): void => {\n  let item: any;\n  if (typeof value !== \"string\") {\n    item = JSON.stringify(value);\n  } else {\n    item = value;\n  }\n\n  localStorage.setItem(`${prefix}_${key.toUpperCase()}`, item);\n};\n\nstorage.get = (key: string): any => {\n  try {\n      const item = localStorage.getItem(`${prefix}_${key.toUpperCase()}`);\n      if (item) {\n          return JSON.parse(item);\n      } else return undefined;\n  } catch (e) {\n    return null;\n  }\n};\n\nexport default storage;","import * as types from \"./types\";\nimport {Dispatch} from \"redux\";\nimport axios from \"axios\";\nimport storage from \"../../utils/storage\"\n\nexport const STORED_JOKES = \"STORED_JOKES\";\n\nexport interface FetchAllJokes {\n}\n\nexport const fetchAllJokes = (): FetchAllJokes => async (dispatch: Dispatch) => {\n    dispatch({type: types.FETCH_ALL_JOKES});\n    try {\n        debugger;\n        let response = storage.get(STORED_JOKES);\n        let fetchedJokes = [];\n\n        if (!response) {\n            response = await axios.get('https://icanhazdadjoke.com/search');\n            fetchedJokes = response.data.results;\n            const totalPages = response.data.total_pages;\n\n            for (let i = 2; i <= totalPages; i++) {\n                response = await axios.get(`https://icanhazdadjoke.com/search?page=${i}`);\n                fetchedJokes.push(...response.data.results);\n            }\n            storage.set(STORED_JOKES, fetchedJokes);\n        } else {\n            fetchedJokes = response;\n        }\n        dispatch({type: types.FETCH_ALL_JOKES_SUCCESS, payload: {fetchedJokes}})\n    } catch (error) {\n        dispatch({type: types.FETCH_ALL_JOKES_FAILED, payload: {error}});\n        throw error;\n    }\n};\n\n\nexport type GeneratorActions = FetchAllJokes;\n\n\n\n\n","export const FETCH_ALL_JOKES = \"FETCH_ALL_JOKES\";\nexport const FETCH_ALL_JOKES_SUCCESS = \"FETCH_ALL_JOKES_SUCCESS\";\nexport const FETCH_ALL_JOKES_FAILED = \"FETCH_ALL_JOKES_FAILED\";\n\n","export const isQuestion = (sentence: string) => sentence.match(/^(why|what|who|where|did|do|how|what's)/i);\nconst notEndingWords = ['a', 'an', 'the', 'if', 'or', 'by', 'but', 'I', ',', 'to', 'the'];\n\nexport const shouldEndSentence = (word: string, upperLimit: number, len: number): boolean => {\n  if (word === undefined || word.length === 0) return true;\n  const possibleEnding = notEndingWords.find(w => w === word) === undefined;\n  return len >= upperLimit && possibleEnding;\n};\n\nexport const initialIsCapital = (word: string) => {\n  if (!word.length) return false;\n  return word[0] !== word[0].toLowerCase();\n};\n\nexport const generateHash = () => {\n    return Math.random().toString(36).substring(2);\n};","import {isQuestion, initialIsCapital, shouldEndSentence, generateHash} from \"./commonFunctions\";\nimport storage from \"./storage\";\nimport {STORED_JOKES} from \"../reducers/generator/actions\";\n\n// Original Response from API\nexport interface Joke {\n  id: string;\n  joke: string;\n}\n\n// For Each word we keep number of times it occurs\n// And also adjacent words.\nexport interface MarkovChainState {\n  [key: string]: {\n    count: number;\n    words: { [key: string]: number };\n  };\n}\n\n// Important for choosing starting word.\nexport interface MarkovChainStartState {\n  [key: string]: number;\n}\n\nexport interface Sentence {\n    sentence: string,\n    wordCount: number,\n}\n\nexport default class MarkovChainGenerator {\n  jokes: Joke[];\n  words: string[];\n  hashMap: MarkovChainState;\n  startWords: MarkovChainStartState;\n  minimumWords: number;\n\n  constructor(jokes: Joke[]) {\n    this.jokes = jokes;\n    this.words = [];\n    this.hashMap = {};\n    this.startWords = {};\n    this.minimumWords = 15;\n    this.tokenizeWords();\n  }\n\n  tokenizeWords(): void {\n    this.jokes.forEach((jokeObj: Joke) => {\n      const jokeString = jokeObj.joke;\n      this.calculateState(jokeString);\n    });\n  }\n\n  updateStartWords = (word: string): void => {\n    if (!this.startWords[word]) {\n      this.startWords[word] = 1;\n    } else {\n      this.startWords[word]++;\n    }\n  };\n\n  addNewWordPairToChain = (firstWord: string, secondWord: string): void => {\n    this.hashMap[firstWord] = {\n      count: 1,\n      words: {\n        [secondWord]: 1,\n      },\n    };\n  };\n\n  increaseCountForAdjacentWord = (firstWord: string, secondWord: string): void => {\n    if (!this.hashMap[firstWord].words[secondWord]) {\n      this.hashMap[firstWord].words[secondWord] = 1;\n    } else {\n      this.hashMap[firstWord].words[secondWord]++;\n    }\n    this.hashMap[firstWord].count++;\n  };\n\n  /** Calculate Probabilities from moving from each word\n     To next one.\n     total probability must be 100%, so that we can always transition\n   **/\n  calculateState(joke: String): void {\n    const jokeWords = joke.replace(/[”‘\"]/g, '').split(' ');\n\n    if (jokeWords.length === 0) return;\n    this.updateStartWords(jokeWords[0]);\n\n    jokeWords.forEach((word, index) => {\n      const firstWord = jokeWords[index];\n      const secondWord = jokeWords[index + 1];\n\n      if (firstWord === secondWord || !secondWord) return;\n\n      if (initialIsCapital(secondWord)) this.updateStartWords(secondWord);\n      else if (!this.hashMap[firstWord]) this.addNewWordPairToChain(firstWord, secondWord);\n      else this.increaseCountForAdjacentWord(firstWord, secondWord);\n    });\n  }\n\n  getRandomWordFromBeginning = (): string => {\n    const numWords = Object.keys(this.startWords).reduce((a, b) => a + this.startWords[b], 0);\n    const randomWord = Math.floor(numWords * Math.random());\n    let count = 0, word: string = '';\n\n    Object.keys(this.startWords).some(key => {\n      word = key;\n      count += this.startWords[key];\n      return count >= randomWord && !(!this.hashMap[key] || this.hashMap[key].count === 1);\n    });\n\n    return word;\n  };\n\n  getRandomWordFromAnotherWord = (word: string): string => {\n    const numWords = Object.keys(this.hashMap[word].words).reduce((a, b) => a + this.hashMap[word].words[b], 0);\n    const randomWord = Math.floor(numWords * Math.random());\n    let count = 0, foundWord: string = '';\n\n    Object.keys(this.hashMap[word].words).some(key => {\n      count += this.hashMap[word].words[key];\n      foundWord = key;\n      return count >= randomWord;\n    });\n\n    return foundWord;\n  };\n\n  handleSentenceEnd = (sentence: string): string => {\n    if (isQuestion(sentence) && sentence.indexOf('?') === -1) {\n      return sentence.slice(0, sentence.length - 1) + '?';\n    } else if (sentence.indexOf('?') > -1) {\n      return sentence.slice(0, sentence.length - 1) + '.';\n    }\n    return sentence;\n  };\n\n  generateSentence = (): Sentence => {\n    let prevWord: string = this.getRandomWordFromBeginning();\n    let sentence: string = prevWord;\n    let count = 1;\n\n    do {\n      if (!this.hashMap[prevWord]) {\n        break;\n      }\n      prevWord = this.getRandomWordFromAnotherWord(prevWord);\n      count++;\n      sentence += ' ' + prevWord;\n    } while (!(shouldEndSentence(prevWord, this.minimumWords, sentence.length) && !this.hashMap[prevWord]));\n\n    sentence = this.handleSentenceEnd(sentence);\n\n    return {\n      sentence: sentence.replace(/\"|‘|“|/g, '').trim(),\n      wordCount: count,\n    };\n  };\n\n  updateStorage = (sentence: string): void => {\n    this.jokes.push({id: generateHash(), joke: sentence});\n    storage.set(STORED_JOKES, this.jokes);\n    this.calculateState(sentence);\n  };\n\n  generateJoke = (): string => {\n    let firstSentence = this.generateSentence();\n    let secondSentence = { sentence: '', wordCount: 0 };\n\n    while (firstSentence.wordCount < 5) firstSentence = this.generateSentence();\n\n    if (firstSentence.wordCount <= this.minimumWords) {\n      do {\n        secondSentence = this.generateSentence();\n      } while (isQuestion(secondSentence.sentence));\n    }\n\n    const sentence = `${firstSentence.sentence} ${secondSentence.sentence}`;\n    this.updateStorage(sentence);\n    return sentence;\n  };\n}\n","import * as React from \"react\";\nimport styles from \"./Button.module.css\";\n\ninterface Props {\n    onClick: () => void;\n    title: string;\n    disabled: boolean;\n}\n\nconst Button = ({onClick, title, disabled}: Props) => {\n    return (\n        <button className={`${styles.button} ${disabled && styles.disabled}`} onClick={onClick}>\n            {title}\n        </button>\n    );\n};\n\nexport default Button;","import * as React from 'react';\nimport logo from '../../logo.svg';\nimport {connect} from \"react-redux\";\nimport {ApplicationState} from \"../../reducers/index\";\nimport {AnyAction, bindActionCreators, Dispatch} from \"redux\";\nimport {fetchAllJokes} from \"../../reducers/generator/actions\";\nimport MarkovChainGenerator from \"../../utils/MarkovChainGenerator\";\nimport {Joke} from \"../../utils/MarkovChainGenerator\";\nimport Button from \"../Button/Button\";\nimport styles from './App.module.css';\n\ninterface Props {\n    fetchAllJokes: () => void;\n    jokes: Joke[],\n    isFetching: boolean;\n}\n\ninterface State {\n    joke: string,\n}\n\nclass App extends React.Component<Props, State> {\n    generator: any;\n\n    state = {\n        joke: \"\"\n    };\n\n    componentWillMount () {\n        this.fetchJokes();\n    }\n\n    fetchJokes = async () => {\n        this.setState({\n           joke: \"Fetching Jokes from API, please wait...\"\n        });\n        await this.props.fetchAllJokes();\n        this.setState({\n            joke: \"Click 'Generate Joke' Button to generate new Joke\"\n        });\n        this.generator = new MarkovChainGenerator(this.props.jokes);\n    };\n\n    generateJoke = () => {\n        const joke = this.generator.generateJoke();\n        this.setState({joke: \"Joke: \" + joke});\n    };\n\n    render() {\n        const {isFetching} = this.props;\n        return (\n            <div className={styles.App}>\n                <header className={styles[\"App-header\"]}>\n                    <img src={logo} className={styles[\"App-logo\"]} alt=\"logo\"/>\n                    <div className={styles.joke}> {this.state.joke} </div>\n                    {isFetching && <div className={styles.loader} />}\n                    <Button onClick={this.generateJoke} title={\"Generate Joke\"} disabled={isFetching} />\n                </header>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = ({generator}: ApplicationState) => ({\n    jokes: generator.fetchedJokes,\n    isFetching: generator.isLoading,\n});\n\nconst mapDispatchToProps = (dispatch: Dispatch<AnyAction>) =>\n    bindActionCreators({\n        fetchAllJokes,\n    }, dispatch);\n\nexport default connect(mapStateToProps, mapDispatchToProps)(App);\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read http://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.1/8 is considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit http://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See http://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl)\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready.then(registration => {\n      registration.unregister();\n    });\n  }\n}\n","import * as Types from \"./types\";\n\nexport type GeneratorState = {\n    isLoading: boolean;\n    fetched: boolean;\n    fetchedJokes: any[];\n};\n\nexport const initialState: GeneratorState = {\n    isLoading: false,\n    fetched: false,\n    fetchedJokes: []\n};\n\ninterface Action {\n  type: string;\n  payload: any;\n}\n\n\nexport default (state = initialState, action: Action) => {\n    const {type, payload} = action;\n\n    switch (type) {\n        case Types.FETCH_ALL_JOKES:\n            return {\n                ...state,\n                isLoading: true,\n                fetched: false,\n                fetchedJokes: []\n            };\n        case Types.FETCH_ALL_JOKES_SUCCESS:\n            return {\n                ...state,\n                isLoading: false,\n                fetched: true,\n                fetchedJokes: [\n                    ...state.fetchedJokes,\n                    ...payload.fetchedJokes,\n                ]\n            };\n        case Types.FETCH_ALL_JOKES_FAILED:\n            return {\n                ...state,\n                isLoading: false,\n                fetched: true,\n                fetchedJokes: []\n            };\n    }\n\n    return state;\n};","import {AnyAction, combineReducers, Reducer} from \"redux\";\n\nimport generatorReducer, {GeneratorState} from \"./generator/index\";\nimport {GeneratorActions} from \"./generator/actions\";\n\nexport interface ApplicationActions {\n    GeneratorActions: GeneratorActions;\n}\n\nexport interface ApplicationState {\n    generator: GeneratorState;\n}\n\nconst reducers: Reducer<ApplicationState, AnyAction> = combineReducers({\n  generator: generatorReducer,\n});\n\n\nexport default reducers;","import * as React from \"react\";\nimport './index.css';\nimport App from './components/App/App';\nimport {render} from \"react-dom\";\nimport * as serviceWorker from './serviceWorker';\nimport {createStore, applyMiddleware} from \"redux\";\nimport thunk from \"redux-thunk\";\nimport {Provider} from \"react-redux\"\nimport reducers from \"./reducers\";\nimport axios from \"axios\";\n\naxios.defaults.headers.common[\"Accept\"] = \"application/json\";\n\nconst rootEl = document.getElementById(\"root\");\nconst store = createStore(reducers, applyMiddleware(thunk));\n\nconst AppWrapper = () => {\n    return (\n        <Provider store={store}>\n            <App/>\n        </Provider>\n    );\n};\n\nrender(<AppWrapper/>, rootEl);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: http://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}